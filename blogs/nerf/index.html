<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>NeRF | Soaroc's Log</title>
<meta name=keywords content="Neural Rendering,NeRF"><meta name=description content="针对NeRF原论文相关细节的介绍."><meta name=author content="Soaroc"><link rel=canonical href=https://soaroc.github.io/blogs/nerf/><link crossorigin=anonymous href=/assets/css/stylesheet.10bdc5c7e32be7886b3e5fbac2b1046d93157121791a5135f1443628fedd7a91.css integrity="sha256-EL3Fx+Mr54hrPl+6wrEEbZMVcSF5GlE18UQ2KP7depE=" rel="preload stylesheet" as=style><link rel=icon href=https://soaroc.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://soaroc.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://soaroc.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://soaroc.github.io/apple-touch-icon.png><link rel=mask-icon href=https://soaroc.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://soaroc.github.io/blogs/nerf/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script type=text/javascript async src="https://cdn.bootcss.com/mathjax/2.7.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML">MathJax.Hub.Config({tex2jax:{inlineMath:[["$","$"],["\\(","\\)"]],displayMath:[["$$","$$"],["[[","]]"]],processEscapes:!0,processEnvironments:!0,skipTags:["script","noscript","style","textarea","pre"],TeX:{equationNumbers:{autoNumber:"AMS"},extensions:["AMSmath.js","AMSsymbols.js"]}}}),MathJax.Hub.Queue(function(){var e,t=MathJax.Hub.getAllJax();for(e=0;e<t.length;e+=1)t[e].SourceElement().parentNode.className+=" has-jax"})</script><style>code.has-jax{font:inherit;font-size:100%;background:inherit;border:inherit;color:#515151}</style><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=Noto+Sans+SC:wght@200&display=swap" rel=stylesheet><meta property="og:title" content="NeRF"><meta property="og:description" content="针对NeRF原论文相关细节的介绍."><meta property="og:type" content="article"><meta property="og:url" content="https://soaroc.github.io/blogs/nerf/"><meta property="og:image" content="https://soaroc.github.io/images/papermod-cover.png"><meta property="article:section" content="blogs"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://soaroc.github.io/images/papermod-cover.png"><meta name=twitter:title content="NeRF"><meta name=twitter:description content="针对NeRF原论文相关细节的介绍."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Blogs","item":"https://soaroc.github.io/blogs/"},{"@type":"ListItem","position":2,"name":"NeRF","item":"https://soaroc.github.io/blogs/nerf/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"NeRF","name":"NeRF","description":"针对NeRF原论文相关细节的介绍.","keywords":["Neural Rendering","NeRF"],"articleBody":"3DGS简介 1、NeRF的缺陷 隐式表达在空间表达上效率不高(存在大量空白区域)，导致训练速度较慢 隐式表达无法充分利用成熟光栅化加速，导致渲染速度较慢 隐式的表达方式，后续的编辑/动画等操作比较困难 2、Prerequisites 2.1、Splatting Points 传统点云(point-based rendering)基于离散的点进行渲染合成，由于点云分布的离散随机性，渲染结果中孔洞、锯齿等问题。通过将点云替换为可splatting(图形学中splatting代表基于透明度的不同纹理融合技术)的基本点结构单元(例如带透明的圆/椭圆/球)等，可以获得高质量等点云渲染效果。\n物体表面任意点的计算公式为：\n$$f_c(u) = \\sum_{k \\in N}w_kr_k(u-u_k)$$\n2.2、Point-based alpha-blending vs. NeRF-style volumetric rendering 2.2.1、Point-based alpha-blending 基于上述公式，实际计算过程中任意像素位置的颜色，通过覆盖该像素点的N个排序后的点(盘/环/球)在当前像素点处采样颜色，并基于其不透明度加权融合计算得到：\n$$C=\\sum_{i \\in N}\\alpha_ic_i\\prod_j^{i-1}(1-\\alpha_j) \\qquad (1)$$\n其中：$c_i, \\alpha_i$分别表示各Splatting Points在该像素点位置处的颜色以及不透明度。\n2.2.2、NeRF-style volumetric rendering NeRF中的体渲染沿单条光线路径积分计算公式为：\n$$C=\\sum_{i=1}^{N}T_i(1-exp(-\\sigma_i\\delta_i))c_i \\quad with \\quad T_i=\\sum_{j=1}^{i-1}exp(-\\sigma_j\\delta_j)=exp(-\\sum_j^{N-1}\\sigma_j\\delta_j)$$\n其中，\n$T_i$：传输方程(Transmittance)，描述了光从采样点/段$\\delta_i$到达相机时未被遮挡的概率； $1-exp(-\\delta_i\\sigma_i)$：当前采样点/段$\\delta_i$的不透明度; $(1-exp(-\\delta_i\\sigma_i))c_i$：该采样点/段的颜色及强度。积分/求和公式表示了沿光线路径上的各不同颜色强度的采样点/段以不同的传输概率在相机位置融合的最终颜色 令$\\alpha_i = 1-exp(-\\delta_i\\sigma_i)$表示当前采样点/段的不透明度，则上述公式可表示为：\n$$C=\\sum_{i=1}^{N}T_i\\alpha_ic_i \\quad with \\quad T_i=\\prod_j^{i-1}(1-\\alpha_j) \\qquad (2)$$\n2.2.3、区别和联系： 由公式(1)和(2)可以看出，两种渲染方式共享相同的计算公式，但：\n在典型的Point-based渲染中，不透明度通常通过对学习到的2D Gaussian的采样计算得到； 在NeRF-like的体渲染中，不透明度则通过沿光线采样，并通过网络计算采样点属性再积分得到。 2.3、3D Gaussian primitive 使用3D高斯单元可以兼容可微分体渲染，实现较好的渲染效果，而且利用其无结构的显式表达方式，实现快速的渲染。一个用于点云渲染的典型3D高斯单元包含如下几个属性：\n位置(x, y, z)：描述了高斯单元的坐标 协方差(3X3矩阵)：描述了高斯单元在三个轴向方向的拉伸缩方尺度。当高斯单元各轴与对应坐标轴线平行时，协方差退化为对角线矩阵。 颜色(RGB)：高斯单元的颜色 不透明度(alpha)：高斯单元的不透明程度 3D高斯单元的几何结构描述为：\n$$G(x) = exp(-\\frac{x^T\\Sigma^{-1}{x}}{2})$$\n其均值即为高斯单元的坐标。3D高斯单元最终投影到2D屏幕空间进行渲染。给定相机视角矩阵W，3D高斯单元的2D投影是2D高斯单元，其协方差矩阵为：\n$$\\Sigma^{’} = JW\\Sigma{W^T}J^T$$\n其中$J$是透视投影放射近似的Jacobian矩阵。该投影2D高斯单元的方差去掉第三行和第三列元素后，即退化为3D空间中带法线椭面单元的2D投影单元(同样是2D高斯单元)。由于协方差矩阵需要保持半正定性，导致实际优化变得复杂。因此实际过程中，通常将协方差矩阵等效为旋转矩阵$R$和缩放矩阵$S$的组合：\n$$\\Sigma= RSS^TR^T$$\n分别通过三维向量s和四元素q独立表达缩放和旋转。\n以四元素q为例，通过求导链式法则，计算其对2D投影单元的协方差矩阵的梯度计算公式：\n$$\\frac{d\\Sigma^{’}}{dq}=\\frac{d\\Sigma^{’}}{d\\Sigma} \\frac{d\\Sigma}{dq} \\quad (3)$$\n定义$U=JW，\\Sigma^{’}=U\\Sigma U^T$，考虑到:\n$$\\sigma^{’}_{ij} = U_{i, *} \\Sigma U_{*,j}^{T} = \\Sigma_{st} U_{is} \\sigma_{st} U_{tj}^{T}$$\n则有:\n$$\\frac{\\partial \\sigma^{’}_{ij}}{\\partial \\sigma_{st}} = U_{is}U_{tj}^{T}=U_{is}U_{jt}$$\n重新整理下标则可得到：\n$$\\frac{\\partial \\Sigma^{’}}{\\partial \\Sigma_{ij}} =\\left[ \\begin{array}{lll} U_{1,i}U_{1,j} \u0026 U_{1,i}U_{2,j} \\\\ U_{1,i}U_{2,j} \u0026 U_{2,i}U_{2,j} \\\\ \\end{array} \\right] \\quad (4)$$\n定义$M=RS，\\Sigma=MM^T$，则：\n$$\\frac{d\\Sigma}{dq}=\\frac{d\\Sigma}{dM} \\frac{d M}{dq}=2M\\frac{dM}{dq} \\quad (5)$$\n$$R(q) =\\left[ \\begin{array}{lll} 1/2-(q^2_j+q^2_k) \u0026 (q_iq_j - q_rq_k) \u0026 (q_iq_k+q_rq_j) \\\\ (q_iq_j+q_rq_k) \u0026 1/2-(q^2_i+q^2_k) \u0026 (q_jq_k-q_rq_i) \\\\ (q_iq_k-q_rq_j) \u0026 (q_jq_k+q_rq_j) \u0026 1/2-(q^2_i+q^2_j) \\\\ \\end{array} \\right]$$\n到缩放矩阵为对角线矩阵，则可得：\n$$\\frac{\\partial M}{\\partial q_r} =\\left[ \\begin{array}{lll} 0 \u0026 -s_yq_k \u0026 s_zq_j \\\\ s_xq_k \u0026 0 \u0026 -s_zq_i) \\\\ -s_xq_j \u0026 s_yq_j \u0026 0 \\\\ \\end{array} \\right] \\quad (6)$$\n同理可计算其它几个分量。将公式(3)~(6)组合即可得到2D投影椭圆协方差矩阵关于旋转矩阵的梯度计算公式\n2.4、球谐光照(Spherical Harmonics) 2.4.1 球谐函数 球谐光照是一种对光照的简化：对于空间上的一点，受到的光照在各个方向上是不同的，也即各向异性，所以空间上一点如果要完全还原光照情况，那就需要记录周围球面上所有方向的光照。球谐函数的主要作用就是用简单的系数表示复杂的球面函数，用于描述光照的分布情况。\n对于任何函数$f(x)$，采用球谐函数展开如下：\n$$f(x) =\\sum_{l=0}^{\\infty}\\sum_{m=-l}^{m=l}c_l^mY_l^m(x)$$\n$$Y_l^m=\\left[ \\begin{aligned} \\sqrt{2}K_l^mcos(m\\phi)P_l^m(cos\\theta) \u0026 \u0026(m\u003e0) \\\\ \\sqrt{2}K_l^msin(-m\\phi)P_l^{-m}(cos\\theta) \u0026 \u0026 (m\u003c0) \\\\ K_l^0P_l^0 \u0026 \u0026 (m=0)\\\\ \\end{aligned} \\right] $$\n其中$Y_l^m$为球谐基函数(在球面坐标系下的定义),$c_l^m$为球谐基系数。$l \\in N$是球谐函数的“次数”，$m \\in [-l, l]$是球谐函数的“阶数”。$K_l^m、P_l^m$分别为与归一化有关的球谐系数缩放因子和勒让德多项式。引入勒让德多项式，保证了球谐基函数的正交性。\n前几阶的球谐基函数公式定义如下所示：\n各球谐基函数可视化效果(将取值作为离原点的距离，颜色区分取值的正负符号进行网格化)如下所示：\n在已知$f(x)$函数或通过蒙托卡罗方法可计算的情况下，球谐基系数$c_l^m$可通过球面投影积分计算得到：\n$$c_l^m =\\int_{\\Omega}f(w)Y_l^m(w)dw$$\n2.4.2 图形渲染的应用 在图形学中，球谐函数通常用来记录某个值在球面上的分布，比如光照情况或颜色分布等。某球谐函数在球坐标系定义为𝑟=𝑓(𝜃,𝜙)，如果𝑟表示了该函数在(𝜃,𝜙)方向上离坐标原点的距离，则其几何结构如左图所示；如果𝑟表示在图形学中一个球体上的高光亮度，则渲染效果如右图所示。\n球谐函数还可用于记录空间中某个点从不同方向看过去的不同颜色，这在点云渲染中非常有用。3DGS就是用球谐函数记录空间中的Gaussian点在不同方向的颜色。实际应用中的球谐函数基函数一般只用到二阶或三阶。 二阶是4个系数，拓展到rgb，每个颜色通道一个系数，就是4 * 3 = 12个系数。 三阶是9个系数，拓展到rgb就是9 * 3 = 27个系数。\n在使用3DGS等技术重建场景过程中，预先并不知道光照分布(即函数$f(x)$)，无法直接得到球谐系数，通常通过网络估计或者优化算法优化得到。在选定球谐阶数后即可确定所要使用的基函数。给定(观察相机)视角方向$(𝜃,𝜙)$，即可计算得到各基函数取值$y_i$，再与学习得到的球谐函数系数$c_i$，点积计算即可得到该点在该观察方向上的最终颜色：\n$$C= \\sum_i c_iy_i$$\n3、3DGS整体框架 3.1、算法框架流程 算法以多张静态场景图片为输入，输出描述场景的密集3D高斯单元集合。每个高斯单元包含描述位置的坐标、描述大小和朝向的协方差、描述颜色的SH球谐系数，以及不透明度等属性组成。通过最小化场景中3D高斯单元的基于点云不透明度混合渲染图和真实图片之间的差异，迭代不断优化每个高斯单元的属性，以及场景中高斯单元的分布密度。整个算法流程图如下所示：\n首先需要对给定的多张静态场景图片进行预处理，获得每张图片在同一个坐标系的相机拍摄位姿。可以使用SfM算法，例如COLMAP等计算。此外，在估计相机位姿的同时，可获得场景的稀疏点云表达，用于初始化场景的3D高斯单元。\n3.2、初始化 以COLMAP的点云初始化场景的3D高斯单元集合。具体的，将点云归一化到单位体空间。在每个点云处，以当前点云坐标为均值，与其最邻近三个点云之间的(三个坐标轴方向)距离均值为协方差构造每个3D高斯单元。点云颜色则用于初始化SH0阶系数。\n3.3、迭代优化 采用随机梯度法优化3D高斯单元的各属性以及密度分布，以最小化渲染图和输入图片。此外增加渲染图和输入图的结构相似约束。最终的优化目标函数为：\n$$L=(1-\\lambda)L_1+\\lambda L_{D-SSIM}$$\n在待优化的属性中，各3D高斯单元的空间位置分布以及大小(协方差)对场景的精细程度表达有重要作用。最常见的两种情况包括：\n欠重构(under-reconstruction)：空间中存在场景几何结构，但未被3D高斯单元充分覆盖，导致该区域出现空白，没有场景结构表达 过重建(over-reconstruction): 尺寸过大的少量3D高斯单元覆盖较小的场景几何结构，导致该几何结构只能由少量高斯单元确定，缺少丰富细节 当上述两种情况下出现时，其2D投影高斯单元在屏幕空间的位置梯度值通常较大(该区域重建效果较差，优化算法试图将周围高斯单元移动到正确的位置)，可在优化过程中通过位置梯度值大小来判定两种情况，并分别进行如下处理：\n欠重构区域，可直接复制该区域已有的较小3D高斯单元来增加/密化3D高斯分布。具体的，复制相同尺寸的高斯单元，并将其分布到上述位置梯度方向的区域，填补空白区域。此外，根据需要适当增加高斯单元集合体积之和以及高斯单元的个数。\n过重建区域，需要将过大的3D高斯单元细分为较小的3D高斯单元。具体的，通过两个尺寸为原较大高斯单元1/1.6的较小高斯单元替换原较大高斯单元。并将原高斯单元作为PDF分布进行采样来获得两个较小尺寸高斯单元的位置。此情况下保持整个高斯单元集合的体积不变，只是增加了高斯单元的个数。\n上述高斯单元集合致密化过程每隔100步的优化迭代后执行一次。\n除了增加3D高斯单元密度外，也需要对不符合要求的单元进行剔除。不符合的单元类型以及剔除操作方式为：\n任何透明度低于指定阈值的高斯单元。在每次致密化(即每隔100步优化)后执行剔除操作 靠近相机前的3D高斯单元，该类型单元聚集会导致的floater瑕疵现象。具体操作为：在每3000次优化迭代后将所有高斯单元设置为接近于透明，再重新进行3D高斯单元透明度优化。由于接近相机的3D高斯单元的透明度在后续迭代中更新较少，会转化为第一种类型的不合格单元，在后续的透明阈值过滤中被剔除。 在3D空间中尺寸过大，或其2D投影尺寸过大的3D高斯单元直接周期性被剔除 整个优化计算流程如下所示：\n3.4、光栅化渲染 针对现有基于点云的alpha-blending渲染算法中需要固定3D高斯单元数目，以及逐像素不透明度排序导致效率低下问题，提出了基于分片的3D高斯单元光栅化渲染，用于近似基于点云的不透明度融合渲染。具体步骤包括：\n3.4.1、基于视锥的剔除 剔除视锥外的3D高斯单元。具体的，只保留位于视锥内99%体积的3D高斯单元。此外，太靠近裁剪面和太远离远裁剪面的高斯单元的2D投影计算不稳定，也需要进行剔除。\n3.4.2、逐tile(分片)排序和渲染 基于分片的渲染示意图如下所示：\n其具体步骤分为：\n第一步：将投影屏幕切分为16x16的分片，并计算每个3D高斯单元的2D投影椭圆单元所覆盖的分片的个数以及索引号\n第二步：组合3D高斯单元在相机视图空间的深度值和其覆盖的分片索引号为该3D高斯单元的全局索引，具体的，使用64bit的变量描述，其低32bit编码深度值，高32bit编码分片索引。全局索引中包含深度值描述了3D高斯单元在空间中离相机的距离，而覆盖的分片数量则描述了3D高斯单元对渲染图像颜色的贡献程度。\n第三步：基于全局索引对所有的高斯单元进行排序后，再构造逐分片的列表，存储了其2D投影覆盖该分片的，经过depth排序的3D高斯单元序列。\n第四步：为每个分片分配一个CUDA线程块(thread block)，并提前将第三步中的高斯单元序列存储到线程块的局部共享存储空间。为分片中每个像素分配一个线程thread，对该分片的3D高斯排序单元由近到远遍历(相对相机位置)，计算累积颜色和不透明度值。\n第五步：对每个像素，如果第四步中累积的不透明度大于指定阈值，则终止该像素线程的计算。每隔指定时间间隔，查询该分片中所有线程的终止状态。如果所有线程都终止，则结束当前分片的计算。\n第六步：在反向梯度计算过程中，需要记录参与融合计算每个像素颜色的所有3D高斯单元在该像素位置处投影点的属性值，从而对参与计算的3D高斯单元属性参数进行更新。由于传输方程中远处点依赖近处点不透明度信息(相对相机位置)，为了方便梯度计算(链式法则从最外围的复合函数开始)，需要从远到近(相对相机位置)进行遍历计算。可直接利用第四步中已经构建的由近到远的排序列表反向即时计算即可，从而避免为每个像素预先存储投影点排序列表。\n第七步：从分片中最远的3D高斯单元逐步向较近的高斯单元遍历。针对每个像素，只有当前遍历时刻的高斯单元(存储在该分片维护的高斯单元排序列表中，第四步)离相机位置小于其自身最远的高斯单元(存储在该像素维护的高斯单元排序列表中，第六步)，才进行该像素的覆盖计算(是否在当前遍历的高斯单元投影中)，并计算梯度更新该高斯单元。通过存储第四步中的累积不透明度，并除以当前时刻的投影点的不透明度，可得从当前点到最近点的累积不透明度，用于不透明度的反向梯度计算(需要用到近处的不透明累积信息)。\n基于分片排序的渲染方法无需逐像素的排序渲染，是alpha-blending融合渲染的一种近似。当3D高斯单元的2D投影与像素尺寸相当时，这种近似所带来的误差可以忽略不计。此外，由于无需限制需要参与梯度更新的3D高斯单元，因此可以表达较复杂和较大纵深的场景，并且无需针对不同场景进行超惨调节(e.g., 参与梯度计算3D高斯单元个数)\n4、其它优化细节 4.1、Warm-up优化 为了改善优化的稳定性，初期阶段在1/4低分辨率图像上进行warm-up优化。在250次以及500次迭代时刻，在分别提高分辨率一倍。\n4.2、SH渐进优化 由于SH系数的优化对视线角度比较敏感。初期较大误差的视线角度可能导致无法获得较好的SH优化结果。通过在初期只优化SH0系数，后续每隔1000步迭代，分别增加高阶SH系数参与优化，提升优化稳定性\n","wordCount":"285","inLanguage":"en","image":"https://soaroc.github.io/images/papermod-cover.png","datePublished":"0001-01-01T00:00:00Z","dateModified":"0001-01-01T00:00:00Z","author":{"@type":"Person","name":"Soaroc"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://soaroc.github.io/blogs/nerf/"},"publisher":{"@type":"Organization","name":"Soaroc's Log","logo":{"@type":"ImageObject","url":"https://soaroc.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://soaroc.github.io/ accesskey=h title="Soaroc's Log (Alt + H)">Soaroc's Log</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://soaroc.github.io/blogs/ title=Posts><span>Posts</span></a></li><li><a href=https://soaroc.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://soaroc.github.io/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://soaroc.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://soaroc.github.io/blogs/>Blogs</a></div><h1 class="post-title entry-hint-parent">NeRF</h1><div class=post-meta>2 min&nbsp;·&nbsp;Soaroc</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#3dgs%e7%ae%80%e4%bb%8b aria-label=3DGS简介>3DGS简介</a><ul><li><a href=#1nerf%e7%9a%84%e7%bc%ba%e9%99%b7 aria-label=1、NeRF的缺陷>1、NeRF的缺陷</a></li><li><a href=#2prerequisites aria-label=2、Prerequisites>2、Prerequisites</a><ul><li><a href=#21splatting-points aria-label="2.1、Splatting Points">2.1、Splatting Points</a></li><li><a href=#22point-based-alpha-blending-vs-nerf-style-volumetric-rendering aria-label="2.2、Point-based alpha-blending vs. NeRF-style volumetric rendering">2.2、Point-based alpha-blending vs. NeRF-style volumetric rendering</a><ul><li><a href=#221point-based-alpha-blending aria-label="2.2.1、Point-based alpha-blending">2.2.1、Point-based alpha-blending</a></li><li><a href=#222nerf-style-volumetric-rendering aria-label="2.2.2、NeRF-style volumetric rendering">2.2.2、NeRF-style volumetric rendering</a></li><li><a href=#223%e5%8c%ba%e5%88%ab%e5%92%8c%e8%81%94%e7%b3%bb aria-label=2.2.3、区别和联系：>2.2.3、区别和联系：</a></li></ul></li><li><a href=#233d-gaussian-primitive aria-label="2.3、3D Gaussian primitive">2.3、3D Gaussian primitive</a></li><li><a href=#24%e7%90%83%e8%b0%90%e5%85%89%e7%85%a7spherical-harmonics aria-label="2.4、球谐光照(Spherical Harmonics)">2.4、球谐光照(Spherical Harmonics)</a><ul><li><a href=#241-%e7%90%83%e8%b0%90%e5%87%bd%e6%95%b0 aria-label="2.4.1 球谐函数">2.4.1 球谐函数</a></li><li><a href=#242-%e5%9b%be%e5%bd%a2%e6%b8%b2%e6%9f%93%e7%9a%84%e5%ba%94%e7%94%a8 aria-label="2.4.2 图形渲染的应用">2.4.2 图形渲染的应用</a></li></ul></li></ul></li><li><a href=#33dgs%e6%95%b4%e4%bd%93%e6%a1%86%e6%9e%b6 aria-label=3、3DGS整体框架>3、3DGS整体框架</a><ul><li><a href=#31%e7%ae%97%e6%b3%95%e6%a1%86%e6%9e%b6%e6%b5%81%e7%a8%8b aria-label=3.1、算法框架流程>3.1、算法框架流程</a></li><li><a href=#32%e5%88%9d%e5%a7%8b%e5%8c%96 aria-label=3.2、初始化>3.2、初始化</a></li><li><a href=#33%e8%bf%ad%e4%bb%a3%e4%bc%98%e5%8c%96 aria-label=3.3、迭代优化>3.3、迭代优化</a></li><li><a href=#34%e5%85%89%e6%a0%85%e5%8c%96%e6%b8%b2%e6%9f%93 aria-label=3.4、光栅化渲染>3.4、光栅化渲染</a><ul><li><a href=#341%e5%9f%ba%e4%ba%8e%e8%a7%86%e9%94%a5%e7%9a%84%e5%89%94%e9%99%a4 aria-label=3.4.1、基于视锥的剔除>3.4.1、基于视锥的剔除</a></li><li><a href=#342%e9%80%90tile%e5%88%86%e7%89%87%e6%8e%92%e5%ba%8f%e5%92%8c%e6%b8%b2%e6%9f%93 aria-label=3.4.2、逐tile(分片)排序和渲染>3.4.2、逐tile(分片)排序和渲染</a></li></ul></li></ul></li><li><a href=#4%e5%85%b6%e5%ae%83%e4%bc%98%e5%8c%96%e7%bb%86%e8%8a%82 aria-label=4、其它优化细节>4、其它优化细节</a><ul><li><a href=#41warm-up%e4%bc%98%e5%8c%96 aria-label=4.1、Warm-up优化>4.1、Warm-up优化</a></li><li><a href=#42sh%e6%b8%90%e8%bf%9b%e4%bc%98%e5%8c%96 aria-label=4.2、SH渐进优化>4.2、SH渐进优化</a></li></ul></li></ul></li></ul></div></details></div><div class=post-content><h1 id=3dgs简介>3DGS简介<a hidden class=anchor aria-hidden=true href=#3dgs简介>#</a></h1><h2 id=1nerf的缺陷>1、NeRF的缺陷<a hidden class=anchor aria-hidden=true href=#1nerf的缺陷>#</a></h2><ul><li>隐式表达在空间表达上效率不高(存在大量空白区域)，导致训练速度较慢</li><li>隐式表达无法充分利用成熟光栅化加速，导致渲染速度较慢</li><li>隐式的表达方式，后续的编辑/动画等操作比较困难</li></ul><h2 id=2prerequisites>2、Prerequisites<a hidden class=anchor aria-hidden=true href=#2prerequisites>#</a></h2><h3 id=21splatting-points>2.1、Splatting Points<a hidden class=anchor aria-hidden=true href=#21splatting-points>#</a></h3><p>传统点云(point-based rendering)基于离散的点进行渲染合成，由于点云分布的离散随机性，渲染结果中孔洞、锯齿等问题。通过将点云替换为可splatting(图形学中splatting代表基于透明度的不同纹理融合技术)的基本点结构单元(例如带透明的圆/椭圆/球)等，可以获得高质量等点云渲染效果。</p><p><img loading=lazy src=gaussian_splat.png alt="gaussian splats"></p><p>物体表面任意点的计算公式为：</p><p>$$f_c(u) = \sum_{k \in N}w_kr_k(u-u_k)$$</p><h3 id=22point-based-alpha-blending-vs-nerf-style-volumetric-rendering>2.2、Point-based alpha-blending vs. NeRF-style volumetric rendering<a hidden class=anchor aria-hidden=true href=#22point-based-alpha-blending-vs-nerf-style-volumetric-rendering>#</a></h3><h4 id=221point-based-alpha-blending>2.2.1、Point-based alpha-blending<a hidden class=anchor aria-hidden=true href=#221point-based-alpha-blending>#</a></h4><p>基于上述公式，实际计算过程中任意像素位置的颜色，通过覆盖该像素点的N个排序后的点(盘/环/球)在当前像素点处采样颜色，并基于其不透明度加权融合计算得到：</p><p>$$C=\sum_{i \in N}\alpha_ic_i\prod_j^{i-1}(1-\alpha_j) \qquad (1)$$</p><p>其中：$c_i, \alpha_i$分别表示各Splatting Points在该像素点位置处的颜色以及不透明度。</p><h4 id=222nerf-style-volumetric-rendering>2.2.2、NeRF-style volumetric rendering<a hidden class=anchor aria-hidden=true href=#222nerf-style-volumetric-rendering>#</a></h4><p>NeRF中的体渲染沿单条光线路径积分计算公式为：</p><p>$$C=\sum_{i=1}^{N}T_i(1-exp(-\sigma_i\delta_i))c_i \quad with \quad T_i=\sum_{j=1}^{i-1}exp(-\sigma_j\delta_j)=exp(-\sum_j^{N-1}\sigma_j\delta_j)$$</p><p>其中，</p><ul><li>$T_i$：传输方程(Transmittance)，描述了光从采样点/段$\delta_i$到达相机时未被遮挡的概率；</li><li>$1-exp(-\delta_i\sigma_i)$：当前采样点/段$\delta_i$的不透明度;</li><li>$(1-exp(-\delta_i\sigma_i))c_i$：该采样点/段的颜色及强度。积分/求和公式表示了沿光线路径上的各不同颜色强度的采样点/段以不同的传输概率在相机位置融合的最终颜色</li></ul><p>令$\alpha_i = 1-exp(-\delta_i\sigma_i)$表示当前采样点/段的不透明度，则上述公式可表示为：</p><p>$$C=\sum_{i=1}^{N}T_i\alpha_ic_i \quad with \quad T_i=\prod_j^{i-1}(1-\alpha_j) \qquad (2)$$</p><h4 id=223区别和联系>2.2.3、区别和联系：<a hidden class=anchor aria-hidden=true href=#223区别和联系>#</a></h4><p>由公式(1)和(2)可以看出，两种渲染方式共享相同的计算公式，但：</p><ul><li>在典型的Point-based渲染中，不透明度通常通过对学习到的2D Gaussian的采样计算得到；</li><li>在NeRF-like的体渲染中，不透明度则通过沿光线采样，并通过网络计算采样点属性再积分得到。</li></ul><h3 id=233d-gaussian-primitive>2.3、3D Gaussian primitive<a hidden class=anchor aria-hidden=true href=#233d-gaussian-primitive>#</a></h3><p>使用3D高斯单元可以兼容可微分体渲染，实现较好的渲染效果，而且利用其无结构的显式表达方式，实现快速的渲染。一个用于点云渲染的典型3D高斯单元包含如下几个属性：</p><ul><li>位置(x, y, z)：描述了高斯单元的坐标</li><li>协方差(3X3矩阵)：描述了高斯单元在三个轴向方向的拉伸缩方尺度。当高斯单元各轴与对应坐标轴线平行时，协方差退化为对角线矩阵。</li><li>颜色(RGB)：高斯单元的颜色</li><li>不透明度(alpha)：高斯单元的不透明程度</li></ul><p>3D高斯单元的几何结构描述为：</p><p>$$G(x) = exp(-\frac{x^T\Sigma^{-1}{x}}{2})$$</p><p>其均值即为高斯单元的坐标。3D高斯单元最终投影到2D屏幕空间进行渲染。给定相机视角矩阵W，3D高斯单元的2D投影是2D高斯单元，其协方差矩阵为：</p><p>$$\Sigma^{&rsquo;} = JW\Sigma{W^T}J^T$$</p><p>其中$J$是透视投影放射近似的Jacobian矩阵。该投影2D高斯单元的方差去掉第三行和第三列元素后，即退化为3D空间中带法线椭面单元的2D投影单元(同样是2D高斯单元)。由于协方差矩阵需要保持半正定性，导致实际优化变得复杂。因此实际过程中，通常将协方差矩阵等效为旋转矩阵$R$和缩放矩阵$S$的组合：</p><p>$$\Sigma= RSS^TR^T$$</p><p>分别通过三维向量s和四元素q独立表达缩放和旋转。</p><p>以四元素q为例，通过求导链式法则，计算其对2D投影单元的协方差矩阵的梯度计算公式：</p><p>$$\frac{d\Sigma^{&rsquo;}}{dq}=\frac{d\Sigma^{&rsquo;}}{d\Sigma} \frac{d\Sigma}{dq} \quad (3)$$</p><p>定义$U=JW，\Sigma^{&rsquo;}=U\Sigma U^T$，考虑到:</p><p>$$\sigma^{&rsquo;}_{ij} = U_{i, *} \Sigma U_{*,j}^{T} = \Sigma_{st} U_{is} \sigma_{st} U_{tj}^{T}$$</p><p>则有:</p><p>$$\frac{\partial \sigma^{&rsquo;}_{ij}}{\partial \sigma_{st}} = U_{is}U_{tj}^{T}=U_{is}U_{jt}$$</p><p>重新整理下标则可得到：</p><p>$$\frac{\partial \Sigma^{&rsquo;}}{\partial \Sigma_{ij}} =\left[
\begin{array}{lll}
U_{1,i}U_{1,j} & U_{1,i}U_{2,j} \\
U_{1,i}U_{2,j} & U_{2,i}U_{2,j} \\
\end{array}
\right] \quad (4)$$</p><p>定义$M=RS，\Sigma=MM^T$，则：</p><p>$$\frac{d\Sigma}{dq}=\frac{d\Sigma}{dM} \frac{d M}{dq}=2M\frac{dM}{dq} \quad (5)$$</p><p>$$R(q) =\left[
\begin{array}{lll}
1/2-(q^2_j+q^2_k) & (q_iq_j - q_rq_k) & (q_iq_k+q_rq_j) \\
(q_iq_j+q_rq_k) & 1/2-(q^2_i+q^2_k) & (q_jq_k-q_rq_i) \\
(q_iq_k-q_rq_j) & (q_jq_k+q_rq_j) & 1/2-(q^2_i+q^2_j) \\
\end{array}
\right]$$</p><p>到缩放矩阵为对角线矩阵，则可得：</p><p>$$\frac{\partial M}{\partial q_r} =\left[
\begin{array}{lll}
0 & -s_yq_k & s_zq_j \\
s_xq_k & 0 & -s_zq_i) \\
-s_xq_j & s_yq_j & 0 \\
\end{array}
\right] \quad (6)$$</p><p>同理可计算其它几个分量。将公式(3)~(6)组合即可得到2D投影椭圆协方差矩阵关于旋转矩阵的梯度计算公式</p><h3 id=24球谐光照spherical-harmonics>2.4、球谐光照(Spherical Harmonics)<a hidden class=anchor aria-hidden=true href=#24球谐光照spherical-harmonics>#</a></h3><h4 id=241-球谐函数>2.4.1 球谐函数<a hidden class=anchor aria-hidden=true href=#241-球谐函数>#</a></h4><p>球谐光照是一种对光照的简化：对于空间上的一点，受到的光照在各个方向上是不同的，也即各向异性，所以空间上一点如果要完全还原光照情况，那就需要记录周围球面上所有方向的光照。球谐函数的主要作用就是用简单的系数表示复杂的球面函数，用于描述光照的分布情况。</p><p>对于任何函数$f(x)$，采用球谐函数展开如下：</p><p>$$f(x) =\sum_{l=0}^{\infty}\sum_{m=-l}^{m=l}c_l^mY_l^m(x)$$</p><p>$$Y_l^m=\left[
\begin{aligned}
\sqrt{2}K_l^mcos(m\phi)P_l^m(cos\theta) & &(m>0) \\
\sqrt{2}K_l^msin(-m\phi)P_l^{-m}(cos\theta) & & (m&lt;0) \\
K_l^0P_l^0 & & (m=0)\\
\end{aligned}
\right] $$</p><p>其中$Y_l^m$为球谐基函数(在球面坐标系下的定义),$c_l^m$为球谐基系数。$l \in N$是球谐函数的“次数”，$m \in [-l, l]$是球谐函数的“阶数”。$K_l^m、P_l^m$分别为与归一化有关的球谐系数缩放因子和勒让德多项式。引入勒让德多项式，保证了球谐基函数的正交性。</p><p>前几阶的球谐基函数公式定义如下所示：</p><p><img loading=lazy src=sh_base_functions.png alt=SH_base_functions></p><p>各球谐基函数可视化效果(将取值作为离原点的距离，颜色区分取值的正负符号进行网格化)如下所示：</p><p><img loading=lazy src=vis_sh_functions.png alt=vis_sh_functions></p><p>在已知$f(x)$函数或通过蒙托卡罗方法可计算的情况下，球谐基系数$c_l^m$可通过球面投影积分计算得到：</p><p>$$c_l^m =\int_{\Omega}f(w)Y_l^m(w)dw$$</p><h4 id=242-图形渲染的应用>2.4.2 图形渲染的应用<a hidden class=anchor aria-hidden=true href=#242-图形渲染的应用>#</a></h4><p>在图形学中，球谐函数通常用来记录某个值在球面上的分布，比如光照情况或颜色分布等。某球谐函数在球坐标系定义为𝑟=𝑓(𝜃,𝜙)，如果𝑟表示了该函数在(𝜃,𝜙)方向上离坐标原点的距离，则其几何结构如左图所示；如果𝑟表示在图形学中一个球体上的高光亮度，则渲染效果如右图所示。</p><p><img loading=lazy src=cg_vis_sh_function.png alt=vis_sh_function></p><p>球谐函数还可用于记录空间中某个点从不同方向看过去的不同颜色，这在点云渲染中非常有用。3DGS就是用球谐函数记录空间中的Gaussian点在不同方向的颜色。实际应用中的球谐函数基函数一般只用到二阶或三阶。 二阶是4个系数，拓展到rgb，每个颜色通道一个系数，就是4 * 3 = 12个系数。 三阶是9个系数，拓展到rgb就是9 * 3 = 27个系数。</p><p>在使用3DGS等技术重建场景过程中，预先并不知道光照分布(即函数$f(x)$)，无法直接得到球谐系数，通常通过网络估计或者优化算法优化得到。在选定球谐阶数后即可确定所要使用的基函数。给定(观察相机)视角方向$(𝜃,𝜙)$，即可计算得到各基函数取值$y_i$，再与学习得到的球谐函数系数$c_i$，点积计算即可得到该点在该观察方向上的最终颜色：</p><p>$$C= \sum_i c_iy_i$$</p><h2 id=33dgs整体框架>3、3DGS整体框架<a hidden class=anchor aria-hidden=true href=#33dgs整体框架>#</a></h2><h3 id=31算法框架流程>3.1、算法框架流程<a hidden class=anchor aria-hidden=true href=#31算法框架流程>#</a></h3><p>算法以多张静态场景图片为输入，输出描述场景的密集3D高斯单元集合。每个高斯单元包含描述位置的坐标、描述大小和朝向的协方差、描述颜色的SH球谐系数，以及不透明度等属性组成。通过最小化场景中3D高斯单元的基于点云不透明度混合渲染图和真实图片之间的差异，迭代不断优化每个高斯单元的属性，以及场景中高斯单元的分布密度。整个算法流程图如下所示：</p><p><img loading=lazy src=3dgs_pipeline.png alt=3dgs_pipeline></p><p>首先需要对给定的多张静态场景图片进行预处理，获得每张图片在同一个坐标系的相机拍摄位姿。可以使用SfM算法，例如COLMAP等计算。此外，在估计相机位姿的同时，可获得场景的稀疏点云表达，用于初始化场景的3D高斯单元。</p><h3 id=32初始化>3.2、初始化<a hidden class=anchor aria-hidden=true href=#32初始化>#</a></h3><p>以COLMAP的点云初始化场景的3D高斯单元集合。具体的，将点云归一化到单位体空间。在每个点云处，以当前点云坐标为均值，与其最邻近三个点云之间的(三个坐标轴方向)距离均值为协方差构造每个3D高斯单元。点云颜色则用于初始化SH0阶系数。</p><h3 id=33迭代优化>3.3、迭代优化<a hidden class=anchor aria-hidden=true href=#33迭代优化>#</a></h3><p>采用随机梯度法优化3D高斯单元的各属性以及密度分布，以最小化渲染图和输入图片。此外增加渲染图和输入图的结构相似约束。最终的优化目标函数为：</p><p>$$L=(1-\lambda)L_1+\lambda L_{D-SSIM}$$</p><p>在待优化的属性中，各3D高斯单元的空间位置分布以及大小(协方差)对场景的精细程度表达有重要作用。最常见的两种情况包括：</p><ul><li>欠重构(under-reconstruction)：空间中存在场景几何结构，但未被3D高斯单元充分覆盖，导致该区域出现空白，没有场景结构表达</li><li>过重建(over-reconstruction): 尺寸过大的少量3D高斯单元覆盖较小的场景几何结构，导致该几何结构只能由少量高斯单元确定，缺少丰富细节</li></ul><p>当上述两种情况下出现时，其2D投影高斯单元在屏幕空间的位置梯度值通常较大(该区域重建效果较差，优化算法试图将周围高斯单元移动到正确的位置)，可在优化过程中通过位置梯度值大小来判定两种情况，并分别进行如下处理：</p><p><strong>欠重构区域</strong>，可直接复制该区域已有的较小3D高斯单元来增加/密化3D高斯分布。具体的，复制相同尺寸的高斯单元，并将其分布到上述位置梯度方向的区域，填补空白区域。此外，根据需要适当增加高斯单元集合体积之和以及高斯单元的个数。</p><p><strong>过重建区域</strong>，需要将过大的3D高斯单元细分为较小的3D高斯单元。具体的，通过两个尺寸为原较大高斯单元1/1.6的较小高斯单元替换原较大高斯单元。并将原高斯单元作为PDF分布进行采样来获得两个较小尺寸高斯单元的位置。此情况下保持整个高斯单元集合的体积不变，只是增加了高斯单元的个数。</p><p>上述高斯单元集合致密化过程每隔100步的优化迭代后执行一次。</p><p>除了增加3D高斯单元密度外，也需要对不符合要求的单元进行剔除。不符合的单元类型以及剔除操作方式为：</p><ul><li>任何透明度低于指定阈值的高斯单元。在每次致密化(即每隔100步优化)后执行剔除操作</li><li>靠近相机前的3D高斯单元，该类型单元聚集会导致的floater瑕疵现象。具体操作为：在每3000次优化迭代后将所有高斯单元设置为接近于透明，再重新进行3D高斯单元透明度优化。由于接近相机的3D高斯单元的透明度在后续迭代中更新较少，会转化为第一种类型的不合格单元，在后续的透明阈值过滤中被剔除。</li><li>在3D空间中尺寸过大，或其2D投影尺寸过大的3D高斯单元直接周期性被剔除</li></ul><p>整个优化计算流程如下所示：</p><p><img loading=lazy src=3dgs_optim_algo.png alt=3dgs_optim_algo></p><h3 id=34光栅化渲染>3.4、光栅化渲染<a hidden class=anchor aria-hidden=true href=#34光栅化渲染>#</a></h3><p>针对现有基于点云的alpha-blending渲染算法中需要固定3D高斯单元数目，以及逐像素不透明度排序导致效率低下问题，提出了基于分片的3D高斯单元光栅化渲染，用于近似基于点云的不透明度融合渲染。具体步骤包括：</p><h4 id=341基于视锥的剔除>3.4.1、基于视锥的剔除<a hidden class=anchor aria-hidden=true href=#341基于视锥的剔除>#</a></h4><p>剔除视锥外的3D高斯单元。具体的，只保留位于视锥内99%体积的3D高斯单元。此外，太靠近裁剪面和太远离远裁剪面的高斯单元的2D投影计算不稳定，也需要进行剔除。</p><h4 id=342逐tile分片排序和渲染>3.4.2、逐tile(分片)排序和渲染<a hidden class=anchor aria-hidden=true href=#342逐tile分片排序和渲染>#</a></h4><p>基于分片的渲染示意图如下所示：</p><p><img loading=lazy src=3dgs_render_illustrate.png alt=3dgs_render_illustrate></p><p>其具体步骤分为：</p><p><strong>第一步</strong>：将投影屏幕切分为16x16的分片，并计算每个3D高斯单元的2D投影椭圆单元所覆盖的分片的个数以及索引号</p><p><strong>第二步</strong>：组合3D高斯单元在相机视图空间的深度值和其覆盖的分片索引号为该3D高斯单元的全局索引，具体的，使用64bit的变量描述，其低32bit编码深度值，高32bit编码分片索引。全局索引中包含深度值描述了3D高斯单元在空间中离相机的距离，而覆盖的分片数量则描述了3D高斯单元对渲染图像颜色的贡献程度。</p><p><strong>第三步</strong>：基于全局索引对所有的高斯单元进行排序后，再构造逐分片的列表，存储了其2D投影覆盖该分片的，经过depth排序的3D高斯单元序列。</p><p><strong>第四步</strong>：为每个分片分配一个CUDA线程块(thread block)，并提前将第三步中的高斯单元序列存储到线程块的局部共享存储空间。为分片中每个像素分配一个线程thread，对该分片的3D高斯排序单元由近到远遍历(相对相机位置)，计算累积颜色和不透明度值。</p><p><strong>第五步</strong>：对每个像素，如果第四步中累积的不透明度大于指定阈值，则终止该像素线程的计算。每隔指定时间间隔，查询该分片中所有线程的终止状态。如果所有线程都终止，则结束当前分片的计算。</p><p><strong>第六步</strong>：在反向梯度计算过程中，需要记录参与融合计算每个像素颜色的所有3D高斯单元在该像素位置处投影点的属性值，从而对参与计算的3D高斯单元属性参数进行更新。由于传输方程中远处点依赖近处点不透明度信息(相对相机位置)，为了方便梯度计算(链式法则从最外围的复合函数开始)，需要从远到近(相对相机位置)进行遍历计算。可直接利用第四步中已经构建的由近到远的排序列表反向即时计算即可，从而避免为每个像素预先存储投影点排序列表。</p><p><strong>第七步</strong>：从分片中最远的3D高斯单元逐步向较近的高斯单元遍历。针对每个像素，只有当前遍历时刻的高斯单元(存储在该分片维护的高斯单元排序列表中，第四步)离相机位置小于其自身最远的高斯单元(存储在该像素维护的高斯单元排序列表中，第六步)，才进行该像素的覆盖计算(是否在当前遍历的高斯单元投影中)，并计算梯度更新该高斯单元。通过存储第四步中的累积不透明度，并除以当前时刻的投影点的不透明度，可得从当前点到最近点的累积不透明度，用于不透明度的反向梯度计算(需要用到近处的不透明累积信息)。</p><p>基于分片排序的渲染方法无需逐像素的排序渲染，是alpha-blending融合渲染的一种近似。当3D高斯单元的2D投影与像素尺寸相当时，这种近似所带来的误差可以忽略不计。此外，由于无需限制需要参与梯度更新的3D高斯单元，因此可以表达较复杂和较大纵深的场景，并且无需针对不同场景进行超惨调节(e.g., 参与梯度计算3D高斯单元个数)</p><h2 id=4其它优化细节>4、其它优化细节<a hidden class=anchor aria-hidden=true href=#4其它优化细节>#</a></h2><h3 id=41warm-up优化>4.1、Warm-up优化<a hidden class=anchor aria-hidden=true href=#41warm-up优化>#</a></h3><p>为了改善优化的稳定性，初期阶段在1/4低分辨率图像上进行warm-up优化。在250次以及500次迭代时刻，在分别提高分辨率一倍。</p><h3 id=42sh渐进优化>4.2、SH渐进优化<a hidden class=anchor aria-hidden=true href=#42sh渐进优化>#</a></h3><p>由于SH系数的优化对视线角度比较敏感。初期较大误差的视线角度可能导致无法获得较好的SH优化结果。通过在初期只优化SH0系数，后续每隔1000步迭代，分别增加高阶SH系数参与优化，提升优化稳定性</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://soaroc.github.io/tags/neural-rendering/>Neural Rendering</a></li><li><a href=https://soaroc.github.io/tags/nerf/>NeRF</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://soaroc.github.io/>Soaroc's Log</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>